#include "Math_SSE.h"

static inline __m128 V(float x) {
	return _mm_set1_ps(x);
}

inline __m128 _mm_pow7_ps(__m128 x) {
	__m128 x2 = _mm_mul_ps(x, x);
	__m128 x4 = _mm_mul_ps(x2, x2);
	return _mm_mul_ps(x, _mm_mul_ps(x2, x4));
}

inline __m128 _mm_square_ps(__m128 x) {
	return _mm_mul_ps(x, x);
}

inline __m128 _mm_deg_2_rad_ps(__m128 x) {
	return _mm_mul_ps(_mm_div_ps(x, _mm_set1_ps(180.0f)),
			  _mm_set1_ps(_MM_PI));
}

inline __m128 _mm_rad_2_deg_ps(__m128 x) {
	return _mm_mul_ps(_mm_div_ps(x, _mm_set1_ps(_MM_PI)),
			  _mm_set1_ps(180.0f));
}

inline __m128 _mm_atan_ps(__m128 x) {
	const __m128 one  = V(1.0f);
	const __m128 pi_2 = V(_MM_PI_2);

	__m128 sign_mask = _mm_and_ps(x, V(-0.0f));
	__m128 abs_x	 = _mm_andnot_ps(sign_mask, x);

	__m128 use_identity_mask = _mm_cmpgt_ps(abs_x, one);

	__m128 x_inv = _mm_div_ps(one, abs_x);

	x = _mm_or_ps(_mm_and_ps(use_identity_mask, x_inv),
		      _mm_andnot_ps(use_identity_mask, abs_x));

	/**
	 *Minimax polynomial approximation on [-1.570796, 1.570796.]
	 *Degree: 11
	 *Theoretical max absolute error: 2.267362e-03
	 *Generated by remez_polyfit.m in GNU Octave
	 **/
	__m128 coeffs[6] = {
	    _mm_set1_ps(-0.00386449f), _mm_set1_ps(0.02831895f),
	    _mm_set1_ps(-0.08927991f), _mm_set1_ps(0.18047639f),
	    _mm_set1_ps(-0.33014157f), _mm_set1_ps(0.99985413f)};
	__m128 y  = coeffs[0];
	__m128 x2 = _mm_mul_ps(x, x);
	y	  = FMADD(y, x2, coeffs[1]);
	y	  = FMADD(y, x2, coeffs[2]);
	y	  = FMADD(y, x2, coeffs[3]);
	y	  = FMADD(y, x2, coeffs[4]);
	y	  = FMADD(y, x2, coeffs[5]);

	y = _mm_mul_ps(y, x);

	__m128 atan_corrected = _mm_sub_ps(pi_2, y);
	y = _mm_or_ps(_mm_and_ps(use_identity_mask, atan_corrected),
		      _mm_andnot_ps(use_identity_mask, y));

	y = _mm_or_ps(y, sign_mask);
	return y;
}

inline __m128 _mm_atan2_ps(__m128 y, __m128 x) {
	const __m128 zero     = V(0.0f);
	const __m128 pi	      = V(_MM_PI);
	const __m128 pi_2     = V(_MM_PI_2);
	const __m128 neg_pi_2 = V(-_MM_PI_2);

	__m128 abs_x = _mm_andnot_ps(V(-0.0f), x);

	__m128 safe_x = _mm_blendv_ps(x, V(1.0f), _mm_cmpeq_ps(abs_x, zero));
	__m128 z      = _mm_div_ps(y, safe_x);
	__m128 atan_z = _mm_atan_ps(z);

	__m128 x_lt0 = _mm_cmplt_ps(x, zero);
	__m128 y_eq0 = _mm_cmpeq_ps(y, zero);
	__m128 y_lt0 = _mm_cmplt_ps(y, zero);
	__m128 y_gt0 = _mm_cmpgt_ps(y, zero);
	__m128 x_eq0 = _mm_cmpeq_ps(x, zero);

	__m128 add_pi = _mm_and_ps(x_lt0, y_gt0);
	__m128 sub_pi = _mm_and_ps(x_lt0, y_lt0);
	__m128 result = atan_z;
	result	      = _mm_add_ps(result, _mm_and_ps(add_pi, pi));
	result	      = _mm_sub_ps(result, _mm_and_ps(sub_pi, pi));

	__m128 x0_y0   = _mm_and_ps(x_eq0, y_eq0);
	__m128 x0_ygt0 = _mm_and_ps(x_eq0, y_gt0);
	__m128 x0_ylt0 = _mm_and_ps(x_eq0, y_lt0);

	result = _mm_blendv_ps(result, zero, x0_y0);
	result = _mm_blendv_ps(result, pi_2, x0_ygt0);
	result = _mm_blendv_ps(result, neg_pi_2, x0_ylt0);

	return result;
}

inline __m128 _mm_sin_ps(__m128 x) {
	const __m128 inv_2pi = V(_MM_1_OVER_2PI);
	const __m128 two_pi  = V(_MM_2PI);
	const __m128 pi	     = V(_MM_PI);

	__m128 k = _mm_mul_ps(x, inv_2pi);
	k	 = _mm_round_ps(k, _MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC);
	x	 = _mm_sub_ps(x, _mm_mul_ps(k, two_pi));
	x	 = _mm_sub_ps(x, pi);

	/**
	 *Minimax polynomial approximation on [-1.570796, 1.570796.]
	 *Degree: 11
	 *Theoretical max absolute error: 3.062454e-10
	 *Generated by remez_polyfit.m in GNU Octave
	 **/
	__m128 coeffs[6] = {
	    _mm_set1_ps(-0.00000002f), _mm_set1_ps(0.00000275f),
	    _mm_set1_ps(-0.00019841f), _mm_set1_ps(0.00833333f),
	    _mm_set1_ps(-0.16666667f), _mm_set1_ps(1.00000000f)};
	__m128 y  = coeffs[0];
	__m128 x2 = _mm_mul_ps(x, x);
	y	  = FMADD(y, x2, coeffs[1]);
	y	  = FMADD(y, x2, coeffs[2]);
	y	  = FMADD(y, x2, coeffs[3]);
	y	  = FMADD(y, x2, coeffs[4]);
	y	  = FMADD(y, x2, coeffs[5]);

	y = _mm_mul_ps(y, -x);
	return _mm_min_ps(_mm_max_ps(y, V(-1.0f)), V(1.0f));
}

inline __m128 _mm_cos_ps(__m128 x) {
	const __m128 inv_2pi = V(_MM_1_OVER_2PI);
	const __m128 two_pi  = V(_MM_2PI);
	const __m128 pi	     = V(_MM_PI);

	__m128 k = _mm_mul_ps(x, inv_2pi);
	k	 = _mm_round_ps(k, _MM_FROUND_TO_ZERO | _MM_FROUND_NO_EXC);
	x	 = _mm_sub_ps(x, _mm_mul_ps(k, two_pi));
	x	 = _mm_sub_ps(x, pi);

	/**
	 *Minimax polynomial approximation on [-1.570796, 1.570796.]
	 *Degree: 11
	 *Theoretical max absolute error: 2.815581e-09
	 *Generated by remez_polyfit.m in GNU Octave
	 **/
	__m128 coeffs[6] = {
	    _mm_set1_ps(-0.00000026f), _mm_set1_ps(0.00002478f),
	    _mm_set1_ps(-0.00138886f), _mm_set1_ps(0.04166666f),
	    _mm_set1_ps(-0.50000000f), _mm_set1_ps(1.00000000f)};
	__m128 y  = coeffs[0];
	__m128 x2 = _mm_mul_ps(x, x);
	y	  = FMADD(y, x2, coeffs[1]);
	y	  = FMADD(y, x2, coeffs[2]);
	y	  = FMADD(y, x2, coeffs[3]);
	y	  = FMADD(y, x2, coeffs[4]);
	y	  = FMADD(y, x2, coeffs[5]);

	y = _mm_mul_ps(y, V(-1.0f));
	return _mm_min_ps(_mm_max_ps(y, V(-1.0f)), V(1.0f));
}
/* A note:
This function is "trained" on the interval [-19.34358496f, 0.0f].
The reason for this is because our exponential function will only ever be called
on x in the range [-121.0f, 0.0f], giving an output in the range
[2.82077009e-53f, 1.0f], which will then be multiplied by 30.
Machine epsilon for floating point values is 1.19209e-7, so we only need enough
accuracy to restrict our output range, on the low end, to 1.19209e-7 / 30.0f.
log(1.19209e-7 / 30) = -19.34358496f.
 */
inline __m128 _mm_exp_ps(__m128 x) {
	x	  = _mm_min_ps(_mm_max_ps(x, V(-87.33654)), V(88.72283));
	__m128	a = V(12102203.0f); /* (1 << 23) / log(2) */
	__m128i b = _mm_set1_epi32(127 * (1 << 23) - 298765);
	__m128i t = _mm_add_epi32(_mm_cvtps_epi32(_mm_mul_ps(a, x)), b);
	return _mm_castsi128_ps(t);
}

inline __m128 _mm_cbrt_ps(__m128 x) {
	/*
	 *Minimax polynomial approximation on [0.00885600, 1.50000000].
	 *Degree: 7
	 *Max absolute error (float): 0.03775400
	 *Generated by remez_polyfit.m in GNU Octave
	 */
	__m128 y = _mm_set1_ps(1.58387721f);
	y	 = FMADD(y, x, _mm_set1_ps(-9.63321877f));
	y	 = FMADD(y, x, _mm_set1_ps(24.27448273f));
	y	 = FMADD(y, x, _mm_set1_ps(-32.80693817f));
	y	 = FMADD(y, x, _mm_set1_ps(25.74853134f));
	y	 = FMADD(y, x, _mm_set1_ps(-12.00173759f));
	y	 = FMADD(y, x, _mm_set1_ps(3.65936875f));
	y	 = FMADD(y, x, _mm_set1_ps(0.17552474f));
	return y;
}
