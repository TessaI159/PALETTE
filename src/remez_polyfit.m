function [coeffs_full, maxerr, x_extrema] = remez_polyfit(f, interval, n, max_iter, tol, mode)
  if nargin < 6
    mode = "mixed";
  end

  a = interval(1);
  b = interval(2);
  sym = abs(a + b) < 1e-12;
  

  % Determine powers to include
  switch mode
    case "even"
      if ~sym
	error("Even mode requires a symmetric interval.")
      end
      powers = n:-1:0;
      powers = powers(mod(powers,2)==0);
      interval = [0, b];
    case "odd"
      if ~sym
	error("Odd mode requires a symmetric interval.")
      end
      powers = n:-1:0;
      powers = powers(mod(powers,2)==1);
      interval = [0, b];
    case "mixed"
      powers = n:-1:0;
      interval = [a, b];
    otherwise
      error("Mode must be 'even', 'odd', or 'mixed'. If even or odd, interval\
  must be symmetric");
  end
  
  m = length(powers);  % number of polynomial coefficients
  N = m + 1;           % number of extrema

  x_extrema = init_chebyshev_extrema(interval(1), interval(2), N);

  for iter = 1:max_iter
    % Solve interpolation system
    A = zeros(N, m + 1);
    for i = 1:N
      A(i, 1:m) = x_extrema(i).^powers;
      A(i, end) = (-1)^(i+1);
    end
    y = f(x_extrema(:));
    sol = A \ y(:);
    coeffs = sol(1:end-1);
    err = sol(end);

    % Build error function
    poly = @(x) polyval_shifted(coeffs, powers, x);
    switch mode
      case "even"
        E = @(x) f(x) - poly(abs(x));
      case "odd"
        E = @(x) f(x) - sign(x).*poly(abs(x));
      case "mixed"
        E = @(x) f(x) - poly(x);
    end

    % Refine extrema using adjacent subintervals
    new_extrema = zeros(1, N);
    new_extrema(1) = interval(1);
    for i = 1:N-1
      left = x_extrema(i);
      right = x_extrema(i+1);
      new_extrema(i+1) = find_local_extremum(E, left, right, tol);
    end

    % Check alternation
    signs = sign(E(new_extrema));
    signs = sign(signs + 1e-13);  % avoid 0
    if ~is_alternating(signs)
      xx = linspace(interval(1), interval(2), 10000);
      ee = abs(E(xx));
      bounds = linspace(interval(1), interval(2), N+1);
      new_extrema = zeros(1, N);
      for i = 1:N
        mask = (xx >= bounds(i)) & (xx <= bounds(i+1));
        [~, idx] = max(ee(mask));
        xx_segment = xx(mask);
        new_extrema(i) = xx_segment(idx);
      end
    end

    % Convergence check
    if max(abs(new_extrema - x_extrema)) < tol
      x_extrema = new_extrema;
      break;
    end

    x_extrema = new_extrema;
  end

  % Build full polynomial
  coeffs_full = zeros(1, n+1);
  coeffs_full(n - powers + 1) = coeffs;

  % Plot
  xx = linspace(interval(1), interval(2), 10000);
  switch mode
    case "even"
      px = polyval_shifted(coeffs, powers, abs(xx));
    case "odd"
      px = polyval_shifted(coeffs, powers, abs(xx)) .* sign(xx);
    case "mixed"
      px = polyval(coeffs_full, xx);
  end
  fx = f(xx);
  ex = fx - px;
  maxerr = max(abs(ex));

  figure;
  subplot(2,1,1);
  plot(xx, fx, 'b', xx, px, 'r--', 'LineWidth', 1.5);
  legend('f(x)', 'P(x)');
  title(sprintf("Remez Approximation on [−%.2f, %.2f], degree %d (%s)", a, a, n, mode));
  xlabel("x"); ylabel("Value"); grid on;

  subplot(2,1,2);
  plot(xx, ex, 'k', 'LineWidth', 1.5); hold on;
  line([min(xx), max(xx)], [maxerr, maxerr], 'Color', 'r', 'LineStyle', '--');
  line([min(xx), max(xx)], [-maxerr, -maxerr], 'Color', 'r', 'LineStyle', '--');
  err_str = sprintf("±%.2e", maxerr);
  text(min(xx), maxerr, [' ' err_str], 'VerticalAlignment', 'bottom', 'Color', 'r');
  text(min(xx), -maxerr, [' -' err_str], 'VerticalAlignment', 'top', 'Color', 'r');
  title("Error Function: f(x) − P(x)");
  xlabel("x"); ylabel("Error"); grid on;

% --- Print symbolic polynomial with all terms in standard notation ---
powers = n:-1:0;
fprintf("\nSymbolic form of minimax polynomial (degree %d, mode = %s):\n", n, mode);
fprintf("P(x) = ");

for i = 1:length(coeffs_full)
  c = coeffs_full(i);
  p = powers(i);

  % Print sign
  if i == 1
    % first term: just print the sign if negative
    if c < 0
      fprintf("-");
      c = -c;
    end
  else
    if c < 0
      fprintf(" - ");
      c = -c;
    else
      fprintf(" + ");
    end
  end

  % Print coefficient and power
  if p == 0
    fprintf("%.12f", c);
  elseif p == 1
    fprintf("%.12fx", c);
  else
    fprintf("%.12fx^%d", c, p);
  end
end
fprintf("\n");
% --- Output parity-filtered coefficients as C array ---
powers = n:-1:0;
switch mode
  case "even"
    filter = mod(powers,2) == 0;
  case "odd"
    filter = mod(powers,2) == 1;
  case "mixed"
    filter = true(size(powers));
end

filtered_coeffs = coeffs_full(filter);
filtered_powers = powers(filter);
array_name = sprintf("coeffs");

fprintf("\n/**\n");
fprintf("*Minimax polynomial approximation on [%f, %f.]\n", a, b);
fprintf("*Degree: %d\n", n);
fprintf("*Theoretical max absolute error: %e\n", maxerr);
fprintf("*Generated by remez_polyfit.m in GNU Octave\n");
fprintf("**/\n")
fprintf("__m128 %s[%d] = {", array_name, length(filtered_coeffs));
for i = 1:length(filtered_coeffs)
  if i < length(filtered_coeffs)
    fprintf("_mm_set1_ps(%.8ff), ", filtered_coeffs(i));
  else
    fprintf("_mm_set1_ps(%.8ff)", filtered_coeffs(i));
  end
end
fprintf("};\n");

% --- Generate Horner's form ---

% Reverse order for Horner's rule
rev_coeffs = filtered_coeffs;
rev_powers = filtered_powers;

% If there are gaps in powers (e.g., mixed mode), fill with explicit pow(x, p)
deg_diff = diff(rev_powers);

				% Start from highest term
  fprintf("__m128 y = coeffs[0];\n");
if strcmp("odd", mode) | strcmp ("even", mode)
  fprintf("__m128 x2 = _mm_mul_ps(x, x);\n");
end
for i = 2:length(rev_coeffs)
  gap = rev_powers(i-1) - rev_powers(i);
  if gap == 1
    fprintf("y = FMADD(y, x, coeffs[%d]);\n", i - 1);
  else
    fprintf("y = FMADD(y, x2, coeffs[%d]);\n", i - 1);
  end
end
end

function tf = is_alternating(signs)
  tf = all(diff(signs) ~= 0);
end

function pval = polyval_shifted(coeffs, powers, x)
  pval = zeros(size(x));
  for k = 1:length(powers)
    pval += coeffs(k) * x.^powers(k);
  end
end

function x0 = find_local_extremum(E, a, b, tol)
  gr = (sqrt(5) - 1) / 2;
  c = b - gr * (b - a);
  d = a + gr * (b - a);
  while abs(c - d) > tol
    if abs(E(c)) > abs(E(d))
      b = d;
    else
      a = c;
    end
    c = b - gr * (b - a);
    d = a + gr * (b - a);
  end
  x0 = (a + b) / 2;
end

function x = init_chebyshev_extrema(a, b, N)
  k = 1:N;
  x = cos((2*k - 1) * pi / (2*N));
  x = 0.5 * ((b - a) * x + (b + a));
  x = sort(x);
end
