#include <inttypes.h>
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <mach/mach_time.h>

#define DELTA 9e-8

static const uint64_t RUNS = 1524288;

uint64_t time_trig(float (*func)(float), const float x, const uint64_t num_runs) {
  /* Warm the function up */
	for (int i = 0; i < 1000; ++i) {
		func(x);
	}

	uint64_t tic = mach_absolute_time();
	for (uint64_t i = 0; i < num_runs; ++i) {

		func(x);
	}
	uint64_t toc = mach_absolute_time();
	
	return (toc - tic);
}


bool float_within(float f1, float f2, float delta) {
  return fabs(f1 - f2) <= delta;
}


float fake_sin(float x) {
  /*
  Minimax polynomial approximation for a function on [0.000000, 1.570796]
  Degree: 5
  Maximum absolute error: 1.1331707354842805e-19
  Generated by remez_polyfit in GNU Octave
*/
  float x2 = x*x;
const float f[3] = {
  8.3321723928e-03f,
  -1.6666666710e-01f,
  1.0000000000e+00f,
};
 return ((f[0]*x2+f[1])*x2+f[2])*x;
}

float fake_cos(float x) {
/*
  Minimax polynomial approximation for a function on [-0.785398, 0.785398]
  Degree: 5
  Maximum absolute error: -1.0757123173624385e-17
  Generated by remez_polyfit in GNU Octave
*/

  float x2 = x*x;
/* float */
  static const float f[6] = {
    5.2778890504e-02f,
    -4.9342710404e-01f,
    1.0002666187e+00f
  };
  return (f[0]*x2+f[1])*x2+f[2];
}

int main() {
  const float bench = M_PI / 8.0f;
  for (float x = 0; x < M_PI / 40.f; x += 0.00000001) {
    if (!float_within(sin(x), fake_sin(x), DELTA)) {
      printf("Failed at %f\n", x);
      printf("sin: %f, fake_sin: %f\n", sin(x), fake_sin(x));
    }
  }
  for (float x = 0; x < M_PI / 2.0f; x += 0.001) {
    if (!float_within(cos(x), fake_cos(x), DELTA)) {
      printf("Failed at %f\n", x);
      printf("cos: %f, fake_cos: %f\n", cos(x), fake_cos(x));
    }
  }
  printf("Over %"PRIu64" runs:\nReal sin takes ~%"PRIu64" nanoseconds\nFake sin takes ~%"PRIu64" nanoseconds\n", RUNS, time_trig(sinf, bench, RUNS), time_trig(fake_sin, bench, RUNS));
  return 0;
}
